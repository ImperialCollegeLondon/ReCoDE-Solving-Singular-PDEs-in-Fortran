{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#turing-patterns-and-partial-differential-equations","title":"Turing Patterns and Partial Differential Equations","text":""},{"location":"#description","title":"Description","text":"<p>This code is a component of the Research Computing and Data Science Examples (ReCoDE) project. It comprises a non-linear partial differential equation (PDE) solver implemented in Fortran, designed to address both boundary value problems (BVP) and initial boundary value problems (IBVP) with temporal progression. The solver's versatility allows it to handle problems in one or two dimensions and can accommodate single equations or pairs of coupled equations. This exemplar showcases several key features of the code, including:</p> <ul> <li>Integration with the Fortran Package Manager (FPM)</li> <li>Utilization of LAPACK libraries</li> <li>Modular architecture for enhanced maintainability and extensibility</li> </ul> <p>To demonstrate its practical application, the code solves a PDE derived from a predator-prey model. This model is renowned for generating solutions that exhibit Turing patterns, which are observed in various biological systems, such as the skin patterns of pufferfish. While prior knowledge of PDEs and predator-prey models is not prerequisite for understanding this example, all relevant mathematical concepts will be elucidated in the subsequent sections.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Complied Codes</li> <li>Fortran Package Manager (FPM)</li> <li>Modular Codes</li> <li>Multipurpose Codes</li> <li>Solving Mathematical Problems (PDEs)</li> <li>Generalising Problems</li> <li>Discretisation in multiple dimensions</li> <li>Use of external libraries (LAPACK and BLAS)</li> <li>Testing Fortran code</li> </ul> Task Time Reading 7 hours Practising 7 hours"},{"location":"#requirements","title":"Requirements","text":"<p>This exemplar is for entry-level researchers with basic knowledge of Fortran syntax. An Introduction to Fortran Course  is available to help you get started.</p>"},{"location":"#academic","title":"Academic","text":"<ul> <li>Ordinary Differential Equations (ODEs): Ordinary differential equations are equations that involve functions of a single independent variable and their derivatives. These equations are fundamental in modeling various physical, biological, and economic phenomena where the rate of change of a quantity is related to the quantity itself. A discussion on ordinary differential equations can be found here</li> <li>Partial Differential Equations (PDEs): Partial differential equations are more complex than ODEs, as they involve functions of multiple independent variables and their partial derivatives. PDEs are crucial in describing many natural phenomena, including heat transfer, fluid dynamics, and quantum mechanics. They allow us to model systems that change with respect to multiple variables simultaneously, such as time and space. A discussion on partial differential equations can be found here.</li> <li>Numerical Techniques: While some differential equations can be solved analytically, many real-world problems require numerical methods for approximation. The numerical techniques used for solving PDEs are often similar to those used for ODEs, but they must account for the additional complexity introduced by multiple variables.</li> <li>Finite Difference Method: One common numerical approach for solving PDEs is the finite difference method. This technique approximates derivatives by differences over small intervals. It discretises the continuous domain of the PDE into a grid or mesh, and the solution is computed at discrete points. This method is particularly useful for problems with regular geometries and is relatively straightforward to implement.</li> </ul> <p>Understanding these concepts is crucial for working with the non-linear PDE solver included in this exemplar. The solver's ability to handle both BVPs and IVBPs makes it a versatile tool for a wide range of applications in scientific computing and mathematical modeling.</p>"},{"location":"#system","title":"System","text":"<ul> <li>A Fortran compiler, such as <code>gfortran</code>: see here for an installation guide.</li> <li>Fortran Package Manager (FPM): see here for an installation guide.</li> <li><code>BLAS</code> external library: see here for a <code>BLAS</code> installation guide here. Mac users can install with homebrew. </li> <li><code>LAPACK</code> external library: see the <code>LAPACK</code> documentation here and here for an installation guide. Mac users can install with homebrew. <code>BLAS</code> must be installed first.</li> <li>Optional: For visualisation of solutions we have made use of <code>MATLAB_R2023a</code> code. These are given in the <code>solver/examples</code> directory. Other visualisation software can be used.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To begin working with this PDE solver, please follow these steps:</p> <ul> <li> <p>Introduction to Fortran Package Manager (FPM): Start by reading the review of Fortran Package Manager in Section 00 which is required for compiling this project. This will provide an introduction to FPM using the <code>fortran_fibonacci</code> repository as an example.</p> </li> <li> <p>Theoretical Background: Section 01 provides a general overview of the problem and the basic techniques employed in the solution.</p> </li> <li> <p>Solver Configuration and Usage: The three parts of Section 03 describes how to run and use the code.</p> </li> <li> <p>Example Problems: Consult Section 9 for detailed instructions on solving specific problems using this code.</p> </li> <li> <p>Advanced Techniques: The remaining sections explain specific coding techniques used in the development of this solver.</p> </li> </ul> <p>This structured learning sequence provides a comprehensive overview of the PDE solver, encompassing its theoretical foundations, practical implementation, operational use, and critically, the coding techniques employed in its development.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause license</p>"},{"location":"00.fortran_package_manager/","title":"00. Fortran Package Manager","text":"<p>The Fortran Package Manager (FPM) is a modern build system and package manager specifically designed for Fortran.  FPM aims to simplify the process of building and testing Fortran software by providing tools and conventions that streamline these tasks. We have used FPM to help build our project.</p> <p>Key Features of FPM:</p> <ul> <li> <p>Easy Project Creation: FPM makes it straightforward to create new Fortran projects with standardized directory structures and documentation.</p> </li> <li> <p>Dependency Management: FPM handles dependencies between Fortran packages, making it easier to include external libraries and manage their versions.</p> </li> <li> <p>Building and Compiling: It automates the compilation process, ensuring that Fortran code is compiled with the appropriate flags and settings.</p> </li> <li> <p>Testing: FPM supports automated testing, which helps in maintaining code quality and reliability.</p> </li> </ul>"},{"location":"00.fortran_package_manager/#how-to-install-fpm","title":"How to install FPM","text":"<p>See here for a guide on how to install FPM. </p>"},{"location":"00.fortran_package_manager/#how-to-use-fpm","title":"How to use FPM","text":"<p>In order to illustrate the uses of FPM we have created a small program in the repository called <code>fortran_fibonacci</code>. In your terminal open this directory. Inside this directory we have a very simple Fortran code built with FPM. The FPM repository was initiated with the command <code>fpm new fortran_fibonacci</code> and following the guide here. </p> <p>To run this program type <code>fpm run -- N</code> where <code>N</code> is an integer. The program should return the <code>N</code>th Fibonacci number.</p> <p>The structure of the repository is given by <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 app\n\u2502   \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 fibonacci.f90\n\u251c\u2500\u2500 LICENSE\n\u2514\u2500\u2500 test\n    \u2514\u2500\u2500 check.f90\n</code></pre> The <code>README.md</code> file describes how to set up the program. The important commands when using FPM are: </p> <ul> <li> <p><code>fpm run</code> which compiles and runs the code</p> </li> <li> <p><code>fpm test</code> which complies and runs the test</p> </li> <li> <p><code>fpm help</code> which prints to screen all the possible FPM commands</p> </li> </ul> <p>The other important file is <code>fpm.toml</code>. This file is used to configure various aspects of a Fortran project. See here for the structure of this file. </p> <p>For now, the important sections are <code>[fortran]</code>, which sets the default compiler settings and <code>[dev-dependencies]</code> which imports the testing framework.</p>"},{"location":"00.fortran_package_manager/#testing","title":"Testing","text":"<p>Here is the testing module for the program. It has a module filed with tests, <code>test_demo</code>, and a program that calls and runs the tests, <code>tester</code>.</p> <p>Starting with <code>test_demo</code>, there are three tests: <code>test_negative</code>, <code>test_0_or_1</code> and <code>test_greater_than_1</code>. All these subroutines have an <code>error</code> as an output. The error is calculated with the intrinsic <code>check</code>; for example on line <code>26</code>, <code>call check(error, fib(-6), -1)</code> checks if <code>fib(-6)==-1</code> and returns an error if it is not.</p> <p>These three tests are collected in the subroutine <code>collect_tests</code> and included in the <code>testsuite</code> unit test. Each <code>new_unittest(string, test)</code> has a string input that gets printed to the screen when the test is run, and a subroutine test that only returns an error. </p> <p>The program <code>tester</code> then calls the <code>testsuite</code> and reports any error it finds. </p>"},{"location":"01.theory/","title":"01. Theory","text":""},{"location":"01.theory/#mathematical-background","title":"Mathematical Background","text":"<p>In applied mathematics, partial differential equations (PDEs) are used to describe the development of physical phenomena.  Frequently these PDEs may incorporate a small parameter, that scale some of the terms in the equation.  If these terms are important then the presence of this small parameter may be critical; setting the parameter to zero can fundamentally alter the nature and behavior of the equations.  A notable example is the Reynolds number in the Navier-Stokes equations, which balances viscous and momentum terms. When the Reynolds number is small, viscous forces predominate, allowing the momentum terms to be neglected. Conversely, when the Reynolds number is large, momentum forces dominate. However, it is not possible to completely neglect the viscous terms, as high Reynolds number flows near boundaries create very thin, highly viscous regions known as boundary layers. Such equations are called singularly perturbed equations. For a simple example of this phenomena applied to an ordinary differential equation (ODE), see example 1 in Section 9.</p> <p>In this exemplar, we will develop a partial differential equation (PDE) solver to address a class of singularly perturbed equations commonly encountered in mathematical biology, specifically reaction-diffusion systems. These systems describe interactions between two competing agents, such as predator and prey or different chemical substances. When one agent diffuses more slowly than the other, the system exemplifies a singularly perturbed equation.</p> <p>Reaction-diffusion systems are renowned for their ability to produce a wide variety of spatial patterns, known as Turing patterns.  These patterns are hypothesized to be responsible for natural phenomena such as the stripes on zebras, the spots on leopards, and the complex skin patterns of giant pufferfish.</p>"},{"location":"01.theory/#general-model","title":"General Model:","text":"<p>Let </p> <p> </p> <p>represent agent densities which vary in both time   and spatial coordinates  and . Reaction-diffusion systems can then be expressed in the form:</p> <p> </p> <p>where  is some small parameter and  and  are given functions.  and  represent reaction terms that may be non-linear. </p> <p>For the spatial boundary conditions, we will consider either Dirichlet boundary conditions  or Neumann boundary conditions.</p> <p>We will additionally specify initial conditions of the system at the start of the simulation, to be evolved over time. </p>"},{"location":"01.theory/#predator-prey-model","title":"Predator-Prey Model:","text":"<p>In a predator-prey models,  represents the prey density and  the predator density. We can imagine the prey  as a quantity of deer wandering around an enclosed area, while the predators  are wolves that limit the deer population. Then  and  may be of the form</p> <p> </p> <p> </p> <p>In this context, the first term of , , represents the prey density increasing with logistic growth.  In contrast, the second term in  (and  itself) represent the predator's response to the prey population, with the understanding that the predator can only consume a limited amount of prey (see type II response). The small parameter  represents a slowly dispersing prey relative to the predators.</p> <p>Here we show a solution to this equation in one dimension where we have the initial conditions </p> <p> </p> <p> </p> <p>We additionally applied Dirichlet boundary conditions at  and  and considered a time domain of . With , we discretised the system with  points in time and  points in space.</p> <p> </p> <p>Notice how the shape of the prey density is retained for a much longer time than that of the predator density.  This is due to the small parameter .</p>"},{"location":"01.theory/#activator-substrate-depletion-model","title":"Activator-Substrate Depletion Model:","text":"<p>The Activator-Substrate Depletion Model is a framework used to describe a specific type of oscillatory behavior observed in biochemical systems. - Activator : A molecule or substance that promotes or accelerates a particular biochemical reaction or process. - Substrate : The substance upon which the activator acts, typically being converted into a product by the action of the activator. Then  and  may be of the form</p> <p> </p> <p> </p> <p>The constant  qualitatively describes the relative rates of chemical reactions for substrate compared to activator. Small  models a scenario when the activator disperses slowly relative to the substrate's dispersion. When  is small and  greater than , Turing patterns may emerge in the solution. </p> <p>Here we have an activator - substrate example where the initial conditions have been given as , where  is a small amount of random noise and . Dirichlet conditions were used at the boundaries. Notice how, despite looking similar, the activator  has more defined structures than .  has more diffusion between the structures. This is due to  being small.</p> <p> </p> <p>See Example 4 in Section 9 for more details.</p>"},{"location":"01.theory/#problem-complexities","title":"Problem Complexities","text":"<p>This system of PDEs is fairly complicated: </p> <ul> <li>Coupled Equations: This system of coupled equations involves both  and , with each equation's solution depending on the other. This interdependence complicates the solution process, as the equations cannot be solved in isolation.</li> <li>Nonlinearity: The functions  and  are typically non-linear, i.e. of the form  or .     Non-linear PDEs are much harder to solve both analytically and numerically. We will tackle nonlinearities numerically with Newton iteration.</li> <li>Spatial and Temporal Dependencies: The variables  and  depend on both time  and spacial coordinates .      The equations are first order in time , which we can handle numerically with temporal marching.</li> <li>Order of Equations: The equations are also second order in space . This second order derivative means we must solve these equations at every point in space concurrently. This second derivative quantity, called the Laplacian of , measures diffusion, or how  changes around a point relative to the points neighbours.</li> <li>Solution Method: To solve this equation numerically we employ a spatial discretisation scheme such as the finite difference scheme. See this exemplar for a introduction to finite differences.</li> <li>Small parameter : As discussed above, the small parameter  indicates that the diffusion of  is much smaller than the diffusion of . When  is smaller, we will see less diffusion in : any structures of  will appear sharper than in .</li> <li>Boundary Layers: If the behavior of the equation results in the formation of a boundary layer, this is handled numerically using non-uniform grids. These grids are denser in regions where rapid changes occur, such as near the boundary layer, and coarser elsewhere. To implement this numerically, the non-uniform grids are mapped to a uniform computational grid, which is then utilised for computing finite differences. Note that in both the examples above, stretched grids are not necessary as the sharpness of the diffusion of  appears uniformly throughout the domain. See example 1 in Section 9 to see the effect of the stretched grid.</li> <li>Boundary conditions:  At a particular boundary  of the domain (this corresponds to an  boundary which is defined for all points in ) a boundary condition must be specified for both  and . Two common types of boundary condition are: <ul> <li>A Dirichlet boundary condition is one of the form , where  is a constant.</li> <li>A Neumann boundary condition is one of the form , where  is a constant.</li> </ul> </li> <li>Initial Conditions: We must specify initial condition of the form , where  is a given function. If we are solving for both  and  then initial conditions will be given for both.</li> </ul>"},{"location":"02.test/","title":"02. Tests","text":"<p>Testing helps verify that the code behaves as expected. By writing and running tests, we as developers can check that our programs produce the correct outputs for given inputs, and that the software performs its intended functions accurately. This is especially important when we are adding new features or modifying current ones. Automated testing with FPM allows developers to run a suite of tests to ensure that recent changes do not break existing functionality.</p> <p>The full test suite in <code>solver/test</code> gives an example of how to test certain aspects of the code and ensure the software is running properly. </p>"},{"location":"02.test/#exercise","title":"Exercise","text":"<p>Design and run a test for the <code>KronProd</code> subroutine in <code>src/linear_algebra.f90</code>.</p> <p>There is a full set of issues for the testing suite here. You can also develop tests relating to any of these issues.</p>"},{"location":"03-1.solver_settings/","title":"03-1. Solver Settings","text":"<p>In this section we will discuss the input file <code>solver/settings.input</code>. This file sets parameters for the solver and domain of the simulation. This the file is read in by the subroutine <code>read_me</code> in the <code>reader.f90</code> module. The relevant inputs extracted from this file are then shared with the rest of the code.</p> <p>We will refer to the equations:</p> <p> </p>"},{"location":"03-1.solver_settings/#explanation-of-file-contents","title":"Explanation of File Contents","text":"<p>This first section is: <pre><code>Settings ________________\n1           !!! Time_switch (time marching if 1)\n1           !!! Non_Linear_switch (non linear if 1)\n2           !!! Eqn_number\n2           !!! Domain_number\n</code></pre></p> <ul> <li> <p><code>Time_switch</code> toggles the the solver between a BVP solver when set to 0 and a IBVP solver when set to 1. When we have a BVP, this is equivalent to setting the time derivatives  and .</p> </li> <li> <p><code>Non_Linear_switch</code> controls the Newton-iteration solver, disabling it when set to 0 and enabling it when set to 1. The equation that we solve when the <code>Non_Linear_switch</code> is 0 is linear, and so  </p> </li> <li> <p><code>Eqn_number</code> sets how many equations to solve. If set to 1, we only solve for . If set to 2, we solve for both  and .</p> </li> <li> <p><code>Domain_number</code> specifies the number of domains. If set to 1, we only solve over one domain .  If set to 2, we only solve over one domain  and .</p> </li> </ul> <p>Domain sections: <pre><code>!!! xdomain settings_____\n30        !!! nx - size of x domain\n0,5   !!! xl, xr - start and end points of x domain\n0,2.25    !!! x_stretch_on or off, grid stretch parameter (xhalf)\n\n!!! ydomain settings_____\n30        !!! ny - size of y domain\n0,5       !!! yl, yr - start and end points of y domain\n0,2.25    !!! y_stretch_on or off, grid stretch parameter (yhalf)\n\n!!! temporal marching settings_____\n1000              !!! nt - size of t domain\n0.d0,10.d0        !!! tl, tr - start and end points of time domain\n</code></pre> Here we set the sizes of the domains. </p> <ul> <li> <p><code>nx</code>, <code>ny</code> and <code>nt</code> set the number of points inside each domain.</p> </li> <li> <p><code>xl</code> and <code>xr</code> are the start and end of the  domain respectively. This is repeated for  and .</p> </li> <li> <p>For the spatial domains  and  we also include a grid stretch switch <code>x_stretch_on</code> and <code>y_stretch_on</code> When set to 0, then we have uniform domains. When set to 1, half the grid points have been clustered between <code>xl</code> and <code>xhalf</code> in a smooth manner. This is the same for .</p> </li> </ul> <pre><code>!!! general settings_____\n4           !!! DiffOrder - order of finite differences scheme\n1.d-6       !!! Newton_Error\n2000        !!! Max_iter - max Newton iterations\n</code></pre> <ul> <li> <p><code>DiffOrder</code> sets the order of the finite differences. Can be 2 (second order),  (fourth order interior and second order boundaries) or  (fourth order).</p> </li> <li> <p><code>Newton_Error</code> sets the tolerance needed to achieve convergence in the non-linear Newton iteration at each step. A smaller number yields a more accurate result.</p> </li> <li> <p><code>Max_iter</code> sets the maximum number of iterations allowed for the non-liner Newton iteration. If we pass this number, convergence is not reached and the solver stops.</p> </li> </ul>"},{"location":"03-2.equation_definitions/","title":"03-2. Equation Definitions","text":"<p>In this section we will discuss how the equations are set in the file <code>src/equations/definitions.f90</code>. Depending on the settings set in <code>settings.input</code> (primarily <code>Eqn_number</code>, <code>Domain_number</code>, <code>Time_switch</code>, and <code>Non_Linear_switch</code>), different subroutines will be called.</p>"},{"location":"03-2.equation_definitions/#explanation-of-file-contents","title":"Explanation of File Contents","text":"<p>The first subroutine to consider is <code>equation1_linear</code>. It sets up terms of the linear equation:</p> <p> </p> <p>This is subroutine will always called regardless of <code>Eqn_number</code> being 1 or 2; if this value is set to 2 then <code>equation2_linear</code> will also be called. The subroutine <code>equation2_linear</code> is exactly the same but solves for  rather than . <code>Ax</code>, <code>Bx</code>, <code>C</code> and <code>D</code> will always be set. <code>Ay</code> and <code>By</code> will only be set if <code>Domain_number</code> is 2.</p> <pre><code>   Subroutine equation1_linear(x, y, Ax, Bx, Ay, By, C, D)\n      real(dp), intent(in) :: x, y ! xposition in the domain\n      real(dp), intent(out) :: Ax, Bx, Ay, By, C, D\n      real(dp) :: epsi\n\n      epsi = 0.05d0\n\n      Ax = epsi\n      Bx = 0.d0\n\n      Ay = epsi\n      By = 0.d0\n\n      C = 0.d0\n      D = 1.d0\n\n   End Subroutine equation1_linear\n</code></pre> <p>This subroutine <code>equation1_BC_X_Bot</code> is a boundary condition and is identical in form to the subroutine above.  However it is only called when  is at the lower boundary <code>xl</code>.  There are four boundary condition subroutines for each equation: </p> <p>For : </p> <ul> <li> <p><code>equation1_BC_X_Bot</code> and <code>equation1_BC_X_Top</code> are always called and provide conditions for the <code>xl</code> and <code>xr</code> boundaries, respectively.</p> </li> <li> <p><code>equation1_BC_Y_Bot</code> and <code>equation1_BC_Y_Top</code> are only called when <code>Domain_number</code> is 2, and provide conditions for the <code>yl</code> and <code>yr</code> boundaries, respectively.</p> </li> </ul> <p>For  (only called when <code>Eqn_number</code> is 2):</p> <ul> <li> <p><code>equation2_BC_X_Bot</code> and <code>equation2_BC_X_Top</code> are always called and provide conditions for the <code>xl</code> and <code>xr</code> boundaries, respectively.</p> </li> <li> <p><code>equation2_BC_Y_Bot</code> and <code>equation2_BC_Y_Top</code> are only called when <code>Domain_number</code> is 2, and provide conditions for the <code>yl</code> and <code>yr</code> boundaries, respectively.</p> </li> </ul> <pre><code>   Subroutine equation1_BC_X_Bot(x, y, Ax, Bx, Ay, By, C, D)\n      real(dp), intent(in) :: x, y ! xposition in the domain\n      real(dp), intent(out) :: Ax, Bx, Ay, By, C, D\n\n      Ax = 0.d0\n      Bx = 1.d0\n\n      Ay = 0.d0\n      By = 0.d0\n\n      C = 0.d0\n      D = 0.d0\n\n   End Subroutine equation1_BC_X_Bot\n</code></pre> <ul> <li>When <code>Time_switch</code> is 1, the following is called to set the initial condition. There is a similar subroutine for  that is called if <code>Eqn_number</code> is 2.</li> </ul> <pre><code>   Subroutine equation1_initial_condition(x, y, IC)\n      real(dp), intent(in) :: x, y ! xposition in the domain\n      real(dp), intent(out) :: IC\n\n      IC = x + y \n\n   End Subroutine equation1_initial_condition\n</code></pre> <ul> <li> <p>When <code>Non_linear</code> is 1, the following is called to set the non-linear terms. There is a similar subroutine for  that is called if <code>Eqn_number</code> is 2.</p> </li> <li> <p>If <code>Eqn_number</code> is 1 then only <code>F</code> and <code>Fu</code> are called.</p> </li> <li> <p>If <code>Eqn_number</code> is 2 then <code>F</code>, <code>Fu</code> and <code>Fv</code> are called.</p> </li> </ul> <pre><code>   Subroutine equation1_non_linear(x, y, u, v, F, Fu, Fv)\n      real(dp), intent(in) :: x, y, u, v\n      real(dp), intent(out) :: F, Fu, Fv\n      !!! F is a function of u *Fu is dF(u,v)/du and Fv is dF(u,v)/dv\n      !!!   Non linear terms do not effect boundaries\n\n      F = u*u*v *u\n      Fu = 2.d0*u*v *1.d0 \n      Fv = u*u\n   End Subroutine equation1_non_linear\n</code></pre>"},{"location":"03-3.fpm_settings/","title":"03-3. FPM Settings","text":"<p>Here we configure the compiler and FPM settings in the file <code>fpm.toml</code>.</p>"},{"location":"03-3.fpm_settings/#explanation-of-file-contents","title":"Explanation of File Contents","text":"<pre><code>name = \"PDE_Solver\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Elliot James\"\nmaintainer = \"ejb321@ic.ac.uk\"\ncopyright = \"Copyright 2024, Elliot James\"\n</code></pre> <p>Here we configure general build settings in the fpm.toml file. Of particular importance to us is linking blas and lapack to FPM using the link variable.</p> <pre><code>[build]\nauto-executables = true\nauto-tests = true\nauto-examples = true\nmodule-naming = false\n\n# adds lapack and blas packages\nlink = [\"blas\", \"lapack\"]\n</code></pre> <p>The following instructs FPM not to install the package as a library.</p> <pre><code>[install]\nlibrary = false\n</code></pre> <p>The following are standard Fortran settings.</p> <pre><code>[fortran]\nimplicit-typing = false\nimplicit-external = true\nsource-form = \"free\"\n</code></pre> <p>The following settings allows FPM to utilize openmp. Although we haven't explicitly parallelized anything in our code, external packages can often use openmp to enhance runtime execution speed.</p> <pre><code>[dependencies]\nopenmp=\"*\"\n</code></pre> <p>The options below sets the name of the executable to be created by FPM.</p> <pre><code>[[executable]]\nname = \"PDE_Solver\"\n</code></pre> <p>The options below allows us to use the <code>test-drive</code> framework to set up and execute testing routines.</p> <pre><code>[dev-dependencies]\ntest-drive.git = \"https://github.com/fortran-lang/test-drive\"\ntest-drive.tag = \"v0.4.0\"\n</code></pre> <p>The options below link the directory <code>src</code> to FPM. This enables FPM to read the <code>.f90</code> files in <code>src</code>. The <code>build-script</code> variable allows the specification of complier settings.</p> <pre><code>[library]\nsource-dir=\"src\"\n#build-script=\" \"\n</code></pre>"},{"location":"04.modules_and_code_structure/","title":"04. Modules and Code Structure","text":""},{"location":"04.modules_and_code_structure/#file-structure","title":"File structure:","text":"<p>The structure of the repository <code>solver</code> is given by</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 settings.input\n\u251c\u2500\u2500 app\n\u2502   \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 equations\n\u2502   \u2502   \u2514\u2500\u2500 2D.f90\n\u2502   \u2502   \u2514\u2500\u2500 builder.f90\n\u2502   \u2502   \u2514\u2500\u2500 definitions.f90\n\u2502   \u2502   \u2514\u2500\u2500 definitions_test.f90\n\u2502   \u2514\u2500\u2500 maths_constants\n\u2502   \u2502   \u2514\u2500\u2500 diff_coeff.f90\n\u2502   \u2502   \u2514\u2500\u2500 fundamental.f90\n\u2502   \u2514\u2500\u2500 Newtons_method.f90\n\u2502   \u2514\u2500\u2500 domain.f90\n\u2502   \u2514\u2500\u2500 equations.f90\n\u2502   \u2514\u2500\u2500 maths_constants.f90\n\u2502   \u2514\u2500\u2500 linear_algebra.f90\n\u2502   \u2514\u2500\u2500 reader.f90\n\u2502   \u2514\u2500\u2500 solve_bvp.f90\n\u2502   \u2514\u2500\u2500 solve_ibvp.f90\n\u2502   \u2514\u2500\u2500 type_kinds.f90\n\u251c\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 check.f90\n\u2502   \u2514\u2500\u2500 test_collection_BVP.f90\n\u2502   \u2514\u2500\u2500 test_collection_lapack.f90\n\u251c\u2500\u2500 examples\n\u251c\u2500\u2500 build\n\u2514\u2500\u2500 LICENSE\n</code></pre> <ul> <li><code>.gitignore</code> tells <code>git</code> to ignore certain files</li> <li><code>fpm.toml</code> sets the FPM and complier settings</li> <li><code>settings.input</code> contains the solver settings and parameters</li> <li>The directory <code>app</code> contains the main parts of the program</li> <li>All remaining Fortran files are in the <code>src</code> directory</li> <li>It's important to note that the names of the modules inside <code>src/equations</code> are given by <code>equations_2D</code>, <code>equations_builder</code>, etc</li> <li>The directory <code>test</code> contains all the testing subroutines</li> <li>The directory <code>examples</code> contains all example equation files. Used in Section 9</li> <li>The directory <code>test</code> contains all the module executables. This can be cleaned with the command <code>fpm clean</code>.</li> </ul>"},{"location":"04.modules_and_code_structure/#general-overview","title":"General Overview:","text":"<p>Here is a general overview of the solver. Each node is it's own subroutine.  The order of operations goes from left to right, up to down.  If there is a double arrow then the new subroutine returns back to the original subroutine without calling any other significant subroutines.</p> <p>We have not described every subroutine here - for example the subroutines <code>domain.f90: initial_domain_settings</code> and <code>equations.f90: equation_setup</code>  will be described in Section 7.</p> <p>Note that <code>main.f90</code> is in the directory <code>app</code>. All other <code>.f90</code> files are in the folder <code>src</code>.</p> <p></p>"},{"location":"05.breaking_up_the_problem/","title":"05. Breaking up the problem","text":"<p>A critical step in building any large, complex project is to break it down into smaller, more manageable tasks. This approach not only structures and streamlines the process but also enhances debugging, optimization, and scalability. Additionally, it facilitates the development of versatile and modular code that can address a variety of problems. In this section we will discuss how we broke down the problem and implemented each step in a modular fashion. </p> <p>For our PDE solver, the aim is to solve equations of the form</p> <p> </p> <p>The key steps of achieving this are:</p>"},{"location":"05.breaking_up_the_problem/#step-1","title":"Step 1:","text":"<p>In one spatial dimension , consider the boundary value problem (BVP) with solution : </p> <p> </p> <p>where  and  are functions. We supplemented this equation with Dirichlet or Neumann boundary conditions. We will discuss how we discretised this equation in Section 6.</p>"},{"location":"05.breaking_up_the_problem/#step-2","title":"Step 2:","text":"<p>We then consider the effect of multiplying the second derivative by a small parameter :</p> <p> </p> <p>The mathematics and code structure will be discussed in Section 7.</p>"},{"location":"05.breaking_up_the_problem/#step-3","title":"Step 3:","text":"<p>We then add in the nonlinearities, by including the non-linear function :</p> <p> </p> <p>This non-linear equation is then solved using Newton-iteration in the module <code>Newton_method.f90</code>.</p>"},{"location":"05.breaking_up_the_problem/#step-4","title":"Step 4:","text":"<p>We then add a second equation for :</p> <p> </p> <p>This is easy to implement with finite differences: if our discretised solution was originally  then the new discretised solution gets written in the form .</p> <p>This is achieved by defining an additional equation in <code>src/equations/definition.f90</code> and then build both equations in the subroutine <code>build_the_matrix</code>. This highlights the modular nature of the code.</p>"},{"location":"05.breaking_up_the_problem/#step-5","title":"Step 5:","text":"<p>We include a second spatial domain :</p> <p> </p> <p>We have dropped the first derivatives here for simplicity.</p> <p>Importantly, this is again coded in a modular way: the new operators are constructed in <code>src/equations/2D.f90</code>. We built copies of the subroutines <code>equation_setup</code>, <code>build_the_matrix</code> and <code>non_linear_setup</code> and constructed the two-dimensional variants <code>equation_setup2D</code>, <code>build_the_matrix2D</code> and <code>non_linear_setup2D</code>. The logic of both sets of subroutines are similar - except the new use of the Kronecker product in <code>equation_setup2D</code>. As an extension it is possible to combine these subroutines - however, we decided to improve readability by keeping them separate.</p>"},{"location":"05.breaking_up_the_problem/#step-6","title":"Step 6:","text":"<p>The final step is to add in the temporal marching and solve the entire IBVP described above. All the required modules and subroutines have already been built. A new temporal marching matrix is defined in the subroutine <code>src/solve_ibvp.f90: implicit_march</code>. </p>"},{"location":"06.discretisation/","title":"06. Discretisation","text":"<p>In one spatial dimension , consider the boundary value problem (BVP) with solution :</p> <p> </p> <p>where  and  are functions. This equation is supplemented with Dirichlet or Neumann boundary conditions.</p> <p>We will solve this problem by discretising the equation using finite differences to turn the differential equation into an algebraic one with matrices.</p> <p>This will involve inverting a matrix which we will achieve with the linear algebra package LAPACK.</p> <p>Solving such equations are described in this exemplar, but we will list the important steps here:</p> <ol> <li>Preprocessing:<ul> <li>Using <code>reader.f90</code> we read in the specified input data from the file <code>settings.input</code>.</li> <li>Using <code>domain.f90</code> we build the uniform computational grids for the problem.</li> <li>With <code>equations/definitions.f90</code> we then specify the equations we are solving, with boundary conditions.</li> </ul> </li> <li>Discretisation:<ul> <li>In <code>equations.f90</code>, specifically in the subroutine <code>build_the_matrix</code>, the equation is spatially discretised into discrete algebraic equations using finite differences.</li> <li>Both the left and right hand side of the equation above need to be assembled, including all boundary conditions.</li> <li>The equation is then transformed in a banded form. This is due to the fact that most of the matrix entries will be zero when finite differences are used. Again refer to this exemplar for more details.</li> </ul> </li> <li>Solution: we then solve the problem in the module <code>solve_bvp.f90</code> by calling on the LAPACK linear solver defined in <code>linear_algebra.f90</code> with the subroutine <code>solver_banded_double_precision</code>.</li> <li>The solution is then outputted to a data file called <code>BVP.dat</code>.</li> </ol>"},{"location":"07.non-uniform_domain/","title":"07. Non-Uniform Domain","text":"<p>We then include the effect of multiplying the second derivative by a small parameter:</p> <p> </p> <p>The primary challenge in discretising this type of problem stems from the formation of a boundary layer near one of the domain's boundaries. This boundary layer presents a unique computational difficulty due to its dual nature. Outside this thin region, the equation's behavior approximates that of the case where . However, within the boundary layer itself, the influence of  becomes significant and cannot be disregarded. This contrast in behavior between the two regions necessitates careful consideration of the discretization process. This is demonstrated in the second plot of example 1 in Section 9, where a uniform grid is used to discretise the problem and leads to the failure of the numerical solution to converge onto the analytical solution.</p> <p>One method of overcoming such a problem is grid stretching. This technique involves clustering more points near the boundary where the boundary layer exists, allowing for a greater resolution in this region. The primary drawback of this approach is that the standard finite difference coefficients are invalid when used on non-uniform grids. While it is possible to derive new coefficients specifically for non-uniform grids, we instead elegantly map the physical domain onto a uniform computational grid. This transformation preserves the benefits of increased resolution near singularities while allowing the use of the standard finite difference coefficients.</p> <p>We can establish a mapping between a non-uniform physical domain  and a uniform computational grid . Given that  represents the number of grid points, the mapping for  is defined as follows: </p> <p> </p> <p>where </p> <ul> <li> <p>  represents the -th point in the physical domain</p> </li> <li> <p>  for  </p> </li> <li> <p> </p> </li> <li> <p>and  is the clustering value that places half the points in between  and .</p> </li> </ul> <p>To convert the PDE from the  domain to the  domain we use the chain rule</p> <p> </p> <p> </p> <p>We call the terms  and  the metrics. We compute these numerically in subroutines <code>first_difference</code> and <code>second_difference</code> in <code>domain.f90</code>. </p> <p>Substituting these derivatives into the PDE results in the modified equation</p> <p> </p> <p>where </p> <p> </p> <p>This is achieved by the subroutine <code>scales</code> in <code>equations/builder.f90</code>. </p> <p>We note that in <code>scales</code> we actually work in terms of  and  as these quantities are easier to compute. From the chain rule:</p> <p> </p> <p> </p>"},{"location":"07.non-uniform_domain/#initial_domain_settings-overview","title":"initial_domain_settings Overview:","text":"<p>All domain considerations are dealt in the module <code>domain.f90</code>. We emphasise that to construct a new domain all that needs to be specified in the subroutine <code>set_up_domain</code> in <code>domain.f90</code> are the domains boundaries, number of discretised points and the grid stretching settings. It is therefore easy to define multiple domains if needed.  </p> <p></p>"},{"location":"07.non-uniform_domain/#equation_setup-overview","title":"equation_setup Overview:","text":"<p>All one-dimensional equations are built from the the modules <code>equations.f90</code> and <code>equations/builder.f90</code>.</p> <p></p>"},{"location":"08.LAPACK/","title":"08. LAPACK","text":"<p>LAPACK, which stands for Linear Algebra PACKage, is a highly regarded software library for numerical linear algebra. It provides routines for solving systems of linear equations, linear least squares problems, eigenvalue problems, and singular value decomposition. LAPACK is widely used in scientific computing and engineering because of its efficiency, reliability, and extensive functionality.</p> <p>LAPACK routines are optimized for performance through the use of the Basic Linear Algebra Subprograms (BLAS) for lower-level operations (such as matrix multiplication).</p> <p>We wish to use LAPACK to solve a linear system in the form  where  is a known matrix,  a known vector and  an unknown vector. One example of a LAPACK solver which achieves this with double precision is <code>dgbsvx</code>. By examining the documentation, this LAPACK routine takes many inputs. Consequently, it's useful to write a specialised subroutine for LAPACK calls that have all of these extra inputs already defined. </p> <p>Consider the subroutine <code>linear_algebra.f90: solver_banded_double_precision</code>. We begin this subroutine with</p> <pre><code>   Subroutine solver_banded_double_precision(n_input, nband, sub_diag, sup_diag, l, rhs, soln)\n</code></pre> <p>The documentation for <code>dgbsvx</code> describes what data the subroutine requires. The next section of our code maps the data the subroutine receives to these requirements. Importantly, we only want the right hand side to be a vector, not a matrix. Therefore the dimensions of <code>B</code> (the <code>LAPACK</code> right hand side) is <code>(:,1)</code>.</p> <p>The <code>dgbsvx</code> call is then made. This is followed by a check on the solution output. This is discussed in the code. </p> <pre><code> !! X is the output\n      Call dgbsvx(FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB, LDAFB, IPIV,&amp;\n         &amp;EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO)\n</code></pre> <p>We then have an <code>if</code> statement on the value of <code>INFO</code> which is returned from <code>dgbsvx</code> and describes whether the solution was successful. If <code>INFO</code> is not equal to zero, then <code>dgbsvx</code> has failed. Writing messages allows us to determine what has gone wrong.</p>"},{"location":"09.example_equations/","title":"09. Example Equations","text":"<p>In this section, we present a set of example equations to illustrate the concepts discussed in earlier sections. While the <code>definitions.f90</code> file and <code>settings.input</code> configuration are provided in the <code>solver/examples</code> directory, it is strongly recommended that you attempt to recreate these results independently. This hands-on approach will enhance your understanding of the numerical methods and their implementation. We have included a few <code>MATLAB</code> codes in the directory <code>solver</code> if you want to visualise your solutions. </p>"},{"location":"09.example_equations/#example-1-singular-perturbation-boundary-value-problem","title":"Example 1: Singular Perturbation Boundary Value Problem","text":"<p>The inputs for this example are found in this directory. Use the code to solve the equation</p> <p> </p> <p>See here for more details on this type of equation.  This is a linear equation in one dimension. The general solution is given by  </p> <ul> <li>Without grid stretching, solve this equation in the cases of  and  with  as the number of grid points. </li> <li>What happens in the region past  as  gets smaller?</li> <li>Use grid stretching to cluster more points closer to end point  of the domain in the cases of  and . What can you conclude?</li> </ul> <p> </p>"},{"location":"09.example_equations/#example-2-non-linear-time-dependent-equation","title":"Example 2: Non-linear time dependent equation","text":"<p>The inputs for this example are found in this directory.</p> <p>Use the code to solve the equation</p> <p> </p> <p>on the domain  </p> <p>with boundary conditions</p> <p> </p> <p>for the solution . The initial conditions are given by</p> <p> </p> <p>on time domain . </p>"},{"location":"09.example_equations/#things-to-note","title":"Things to note:","text":"<p>There are two interesting behaviours that occur from the solution: 1. First the solution becomes constant very rapidly. This is due to the diffusive term . 2. Secondly, the solution tends to . This is because of the non-linear term : the time dependent equation is given by</p> <p> </p> <p>and as  becomes constant the term     </p> <p>becomes zero. We are left with </p> <p> </p> <p>with the solution  being an attractor i.e the solution  is dominate over .</p> <p></p>"},{"location":"09.example_equations/#example-3-predator-prey-model","title":"Example 3: Predator-Prey Model","text":"<p>The inputs for this example are found in this directory.</p> <p>Attempt to solve the following coupled equation </p> <p> </p> <p>where , on the domain</p> <p> </p> <p>with boundary conditions</p> <p> </p> <p>and time domain  </p> <p>Use the initial conditions</p> <p> </p> <p> </p> <p></p>"},{"location":"09.example_equations/#exercises","title":"Exercises:","text":"<ul> <li>How do the initial conditions change the behaviour of the predator and prey?</li> <li>Can you set up the system so that the prey die off?</li> </ul>"},{"location":"09.example_equations/#example-4-turing-patterns","title":"Example 4: Turing Patterns","text":"<p>The inputs for this example are found in this directory.</p> <p>Attempt to solve the following:</p> <p> </p> <p>where  and , on the domains </p> <p> </p> <p>and time domain </p> <p> </p> <p>Use the boundary conditions:</p> <p> </p> <p> </p> <p>and initial conditions given by</p> <p> </p> <p>where  is a random number between  and . Be careful with the number of spatial grid points; as we are in two dimensions the sizes of the matrices get huge very quickly and slow down the computation. This can be addressed with the use of parallel computing and <code>openmp</code>.  We used .</p> <p>Hint: use the following intrinsic functions for <code>r</code></p> <pre><code>  Call random_seed()\n  Call random_number(r)\n</code></pre> <p>We note that for this particular problem, the small parameter  that multiplies the second derivatives in the first equation does not cause a boundary layer to form in the PDE. Instead, the pattern made by  will be less diffuse than the pattern made by  all across the domain.</p> <p>For a greater discussion see here.</p> <p> </p>"},{"location":"assets/mermaid_diagrams/","title":"General Overview Diagram","text":"<pre><code>graph TD;\n    main.f90 &lt;--&gt; id0(reader.f90: read_me);\n    main.f90 &lt;--&gt;  id1(maths_constants/diff_coeff.d90: diff_initialisation)\n    main.f90 &lt;--&gt; id2(domain.f90: initial_domain_settings)\n    main.f90 --&gt; id3(equations.f90: equation_runner)\n    id3(equations.f90: equation_runner)  --&gt; id4{{Domain_number}}\n    id4{{Eqn_switch}} --&gt;|Domain_number = 1| id5(equations.f90: equation_setup)\n    id4{{Eqn_switch}}  --&gt; |Domain_number = 2| id6(equations/2D.f90: equation_setup2D)\n    id5(equations.f90: equation_setup) --&gt; id7(linear_algebra.f90: band_the_matrix)\n    id6(equations/2D.f90: equation_setup2D) --&gt; id7(linear_algebra.f90: band_the_matrix)\n    id7(linear_algebra.f90: band_the_matrix) --&gt; main.f90\n    main.f90 ------&gt; id8{{Times_switch}}\n    id8{{Times_switch}} --&gt;|Times_switch = 0| id9(solve_bvp.f90: bvp_runner)\n    id8{{Times_switch}}  --&gt; |Times_switch = 1| id10(solve_ibvp.f90: ibvp_runner)\n</code></pre>"},{"location":"assets/mermaid_diagrams/#initial-domain-settings-diagram","title":"Initial Domain Settings Diagram","text":"<pre><code>graph TD;\n    id0(domain.f90: initial_domain_settings) &lt;--&gt; id1(domain.f90: time_domain);\n    id0(domain.f90: initial_domain_settings) --&gt; id2(domain.f90: set_up_domain);\n    id2(domain.f90: set_up_domain) --&gt; id3{{Domain_number}}\n    id3{{Domain_number}} --&gt; |Domain_number = 1| id0(domain.f90: initial_domain_settings)\n    id3{{Domain_number}} --&gt; |Domain_number = 2| id4(domain.f90: set_up_domain)\n    id4(domain.f90: set_up_domain) --&gt; id0(domain.f90: initial_domain_settings)\n\n    id5(domain.f90: set_up_domain) --&gt; id6{{Stretch_Parameter}}\n    id6{{Stretch_Parameter}} --&gt; | Stretch_Parameter = 0 | id7(domain.f90: mapping_no_stretch)\n    id6{{Stretch_Parameter}} --&gt; | Stretch_Parameter = 1 | id8(domain.f90: mapping_stretch)\n    id7(domain.f90: mapping_no_stretch) --&gt; id5(domain.f90: set_up_domain)\n    id8(domain.f90: mapping_stretch) --&gt; id5(domain.f90: set_up_domain)\n    id5(domain.f90: set_up_domain) &lt;----&gt; id9(domain.f90: metrics)\n    id9(domain.f90: metrics) &lt;--&gt; id10(domain.f90: first_difference)\n    id9(domain.f90: metrics) &lt;--&gt; id11(domain.f90: second_difference)\n</code></pre>"},{"location":"assets/mermaid_diagrams/#equation-setup-diagram","title":"Equation Setup Diagram","text":"<pre><code>graph TD;\n    id0(equation.f90: equation_setup) --&gt; id1(equation.f90: build_the_matrix)\n    id1(equation.f90: build_the_matrix) --&gt; id2{{Eqn_number}}\n    id2{{Eqn_number}} --&gt; |Eqn_number = 1| id0(equation.f90: equation_setup)\n    id2{{Eqn_number}} --&gt; |Eqn_number = 2| id3(equation.f90: build_the_matrix)\n    id3(equation.f90: build_the_matrix) --&gt; id0(equation.f90: equation_setup) \n\n    id4(equation.f90: build_the_matrix) &lt;--&gt; id5(equation.f90: equation1_BC_X_Bot)\n    id4(equation.f90: build_the_matrix) &lt;--&gt; id6(equation.f90: equation1_BC_X_Top)\n    id4(equation.f90: build_the_matrix) --&gt; |N-3 times| id7(equation.f90: equation1_linear)\n    id7(equation.f90: equation1_linear) --&gt; id4(equation.f90: build_the_matrix)\n    id4(equation.f90: build_the_matrix) ----&gt; id8(equations/builder.f90: scales)\n    id8(equations/builder.f90: scales) ----&gt; |N times| id4(equation.f90: build_the_matrix)\n    id4(equation.f90: build_the_matrix) &lt;------&gt; id9(equations/builder.f90: derivative_runner)\n    id9(equations/builder.f90: derivative_runner) &lt;--&gt; d11(equations/builder.f90: zero)\n    id9(equations/builder.f90: derivative_runner) &lt;--&gt; d12(equations/builder.f90: first)\n    id9(equations/builder.f90: derivative_runner) &lt;--&gt; d13(equations/builder.f90: second)\n</code></pre>"}]}