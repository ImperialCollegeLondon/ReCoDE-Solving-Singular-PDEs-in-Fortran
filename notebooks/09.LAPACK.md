# 09. LAPACK

LAPACK, which stands for Linear Algebra PACKage, is a highly regarded software library for numerical linear algebra. It provides routines for solving systems of linear equations, linear least squares problems, eigenvalue problems, and singular value decomposition. LAPACK is widely used in scientific computing and engineering because of its efficiency, reliability, and extensive functionality.

LAPACK routines are optimized for performance through the use of the Basic Linear Algebra Subprograms (BLAS) for lower-level operations (such as matrix multiplication).

We wish to use LAPACK to solve a linear system in the form $A x = b$ where $A$ is a known matrix, $b$ a known vector and $x$ an unknown vector. One example of a LAPACK solver which achieves this with double precision is [`dgbsvx`](netlib.org/lapack/explore-html/d1/da6/group__gbsvx_ga38273d98ae4d598529fc9647ca847ce2.html#ga38273d98ae4d598529fc9647ca847ce2). By examining the documentation, this LAPACK routine takes many inputs. Consequently, it's useful to write a specialised subroutine for LAPACK calls that have all of these extra inputs already defined. 

Consider the subroutine `linear_algebra.f90: solver_banded_double_precision`. We begin this subroutine with

```fortran
   Subroutine solver_banded_double_precision(n_input, nband, sub_diag, sup_diag, l, rhs, soln)
```

These are the only inputs (and outputs) we require on our end. All the terms deined in the documentation for [`dgbsvx`](netlib.org/lapack/explore-html/d1/da6/group__gbsvx_ga38273d98ae4d598529fc9647ca847ce2.html#ga38273d98ae4d598529fc9647ca847ce2) have been directly copied from the website:

```fortran
      character*1 ::   FACT
      character*1 ::  TRANS
      integer   ::  N
      integer   ::  KL
      integer   ::  KU
      integer   ::  NRHS
      real(dp), dimension(:, :), allocatable :: AB
      integer   ::  LDAB
      real(dp), dimension(:, :), allocatable  ::   AFB
      integer   ::  LDAFB
      integer, dimension(:), allocatable  ::   IPIV
      character*1 ::   EQUED
      real(dp), dimension(:), allocatable  ::  R
      real(dp), dimension(:), allocatable  ::  C
      real(dp), dimension(:, :), allocatable :: B
      integer   ::  LDB
      real(dp), dimension(:, :), allocatable :: X
      integer   ::  LDX
      real(dp)  ::  RCOND
      real(dp), dimension(:), allocatable  :: FERR
      real(dp), dimension(:), allocatable  ::  BERR
      real(dp), dimension(:), allocatable  ::  WORK
      integer, dimension(:), allocatable  ::  IWORK
      integer   ::  INFO
```
The next section of code sets our data to the LAPACK data:
```fortran
      KL = sub_diag
      KU = sup_diag
      N = n_input
      NRHS = 1

      LDAB = nband
      allocate (AB(LDAB, n_input))
      AB = l

      !! More lapack specific settings (copied from website)

      LDAFB = 2*KL + KU + 1
      allocate (AFB(LDAFB, N))
      allocate (IPIV(1:N))

      EQUED = 'N'

      allocate (R(1:N), C(1:N))

      LDB = N ! Dimension of B
      allocate (B(LDB, NRHS))
      B(:, 1) = rhs

      LDX = N
      allocate (X(LDX, NRHS))
      allocate (BERR(NRHS), FERR(NRHS))
      allocate (WORK(max(1, 3*N)), IWORK(N))
```
The `dgbsvx` call is then made. This is followed by a check on the solution output. This is discussed in the documentation. 
```fortran
 !! X is the output
      Call dgbsvx(FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB, LDAFB, IPIV,&
         &EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO)
```
We then have an `if` statement on the value of `INFO`. If `INFO` is not equal to zero, then `dgbsvx` has failed. Writing messages allows us to determine what has gone wrong. These conditions are from the lapack website.

